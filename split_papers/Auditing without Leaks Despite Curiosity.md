<|startofpaper|>
## Auditing without Leaks Despite Curiosity

HAGIT ATTIYA, Technion, Israel

ANTONIO FERN√ÅNDEZ ANTA, IMDEA Software &amp; Networks Inst., Spain

ALESSIA MILANI, Aix Marseille Univ, CNRS, LIS, France

ALEXANDRE RAPETTI,

Universit√© Paris-Saclay, CEA, List, France

CORENTIN TRAVERS, Aix Marseille Univ, CNRS, LIS, France

Auditing data accesses helps preserve privacy and ensures accountability by allowing one to determine who accessed (potentially sensitive) information. A prior formal definition of register auditability was based on the values returned by read operations, without accounting for cases where a reader might learn a value without explicitly reading it or gain knowledge of data access without being an auditor .

This paper introduces a refined definition of auditability that focuses on when a read operation is effective , rather than relying on its completion and return of a value. Furthermore, we formally specify the constraints that prevent readers from learning values they did not explicitly read or from auditing other readers' accesses.

Our primary algorithmic contribution is a wait-free implementation of a multi-writer, multi-reader register that tracks effective reads while preventing unauthorized audits. The key challenge is ensuring that a read is auditable as soon as it becomes effective, which we achieve by combining value access and access logging into a single atomic operation. Another challenge is recording accesses without exposing them to readers, which we address using a simple encryption technique (one-time pad).

We extend this implementation to an auditable max register that tracks the largest value ever written. The implementation deals with the additional challenge posed by the max register semantics, which allows readers to learn prior values without reading them.

The max register, in turn, serves as the foundation for implementing an auditable snapshot object and, more generally, versioned types . These extensions maintain the strengthened notion of auditability, appropriately adapted from multi-writer, multi-reader registers.

## CCS Concepts: ¬∑ Theory of computation ‚Üí Distributed algorithms .

Additional Key Words and Phrases: Auditability, Wait-free implementation, Synchronization power, Distributed objects, Shared memory

## 1 INTRODUCTION

Auditing is a powerful tool for determining who had access to which (potentially sensitive) information. Auditability is crucial for preserving data privacy, as it ensures accountability for data access. This is particularly important in shared, remotely accessed storage systems, where understanding the extent of a data breach can help mitigate its impact.

## 1.1 Auditable Read/Write Registers

Auditability was introduced by Cogo and Bessani [8] in the context of replicated read/write registers . An auditable register extends traditional read and write operations with an additional audit operation that reports which register values have been read and by whom. The auditability definition by Cogo and Bessani is tightly coupled with their multi-writer, multi-reader register emulation in a replicated storage system using an information-dispersal scheme.

An implementation-agnostic auditability definition was later proposed [5], based on collectively linearizing read, write, and audit operations. This work also analyzes the consensus number required for implementing auditable single-writer registers, showing that it scales with the number of readers and auditors. However, this definition assumes that a reader only gains access to values that are explicitly returned by its read operations. This assumption does not

account for situations where a reader learns the register's value before it has officially returned, making the read operation effective . Hence, a notable limitation of this definition is that a process with an effective read can refuse to complete the operation, thereby avoiding detection by the audit mechanism.

Prior work has also overlooked the risk of non-auditors learning values without explicitly reading them or inferring accesses of other processes. Even when processes follow their prescribed algorithms without active misbehavior, existing auditable register implementations allow an 'honest but curious' process to learn more than what its read operations officially return. Additionally, extending auditability beyond read/write registers remained an unexplored territory.

## 1.2 Our Contributions and Techniques

In this work, we propose a stronger form of auditability for read/write registers, ensuring that all effective reads are auditable and that non-auditors cannot infer the values read by other processes. We further extend these properties to other data structures and propose new algorithms that fulfill these guarantees.

We define new properties that ensure operations do not leak information when processes are honest-but-curious [13] (see Section 2). Firstly, we introduce an implementation-agnostic definition of an effective operation , which is applicable, for instance, to read operations in an auditable register. An operation is effective if a process has determined its return value in all executions indistinguishable to it. Secondly, we define uncompromised operations , saying, for example, that in a register, readers do not learn which values were read by other readers or gain information about values they do not read. This definition is extended beyond registers. For arbitrary data objects, we specify that an operation is uncompromised if there is an indistinguishable execution where the operation does not occur.

Enforcing uncompromised operations in auditable objects poses a challenge since it is, in a sense, antithetical to securely logging data accesses. Our primary algorithmic contribution (Section 3) is a wait-free, linearizable implementation of an auditable multi-writer, multi-reader register. Our implementation ensures that all effective reads are auditable while preventing information leaks: reads are uncompromised by other readers, and cannot learn previous values unless they actually read them. As a consequence, the implementation is immune to a honest-but-curious attacker.

To achieve these properties, our algorithm carefully combines value access with access logging. Additionally, access logs are encrypted using one-time pads known only to writers and auditors. The subtle synchronization required in our implementation is achieved by using compare &amp; swap and fetch &amp; xor (in addition to ordinary reads and writes). Such strong synchronization primitives are necessary since even simple single-writer auditable registers can solve consensus [5]. The correctness proof of the algorithm, of basic linearizability properties as well as of advanced auditability properties, is intricate and relies on a careful linearization function.

Our second algorithmic contribution is an elegant extension of the register implementation to other commonly-used objects. We first extend our framework to a wait-free, linearizable implementation of an auditable multi-writer, multireader max register [2], which returns the largest value ever written. The semantics of a max register, together with tracking the number of operations applied to it (needed for logging accesses), may leak information to the reader about values it has not effectively read. We avoid this leakage by adding a random nonce , serving to introduce some noisiness, to the values written. (See Section 4.) As before, all effective reads are auditable, and no additional information is leaked.

In Section 5, we demonstrate how an auditable max register enables auditability in other data structures. Specifically, we implement auditable extension of atomic snapshots [1] and more generally, of versioned types [11]. Many useful objects, such as counters and logical clocks, are naturally versioned or can be made so with minimal modification.

## 1.3 Related Work

Cogo and Bessani [8] present an algorithm to implement an auditable regular register, using ùëõ ‚â• 4 ùëì + 1 atomic read/write shared objects, ùëì of which may fail by crashing. Their high-level register implementation relies on information dispersal schemes, where the input of a high-level write is split into several pieces, each written in a different low-level shared object. Each low-level shared object keeps a trace of each access, and in order to read, a process has to collect sufficiently many pieces of information in many low-level shared objects, which allows to audit the read.

In asynchronous message-passing systems where ùëì processes can be Byzantine, Del Pozzo, Milani and Rapetti [10] study the possibility of implementing an atomic auditable register, as defined by Cogo and Bessani, with fewer than 4 ùëì + 1 servers. They prove that without communication between servers, auditability requires at least 4 ùëì + 1 servers, ùëì of which may be Byzantine. They also show that allowing servers to communicate with each other admits an auditable atomic register with optimal resilience of 3 ùëì + 1.

Attiya, Del Pozzo, Milani, Pavloff and Rapetti [5] provides the first implementation-agnostic auditability definition. Using this definition they show that auditing adds power to reading and writing, as it allows processes to solve consensus, implying that auditing requires strong synchronization primitives. They also give several implementations that use non-universal primitives (like swap and fetch&amp;add), for a single writer and either several readers or several auditors (but not both).

When faulty processes are malicious , accountability [6, 7, 14, 18] aims to produce proofs of misbehavior in instances where processes deviate, in an observable way, from the prescribed protocol. This allows the identification and removal of malicious processes from the system as a way to clean the system after a safety violation. In contrast, auditability logs the processes' actions and lets the auditor derive conclusions about the processes' behavior.

In addition to tracking access to shared data, it might be desirable to give to some designated processes the ability to grant and/or revoke access rights to the data. Frey, Gestin and Raynal [12] specify and investigate the synchronization power of shared objects called AllowList and DenyList , allowing a set of manager processes to grant or revoke access rights for a given set of resources.

## 2 DEFINITIONS

Basic notions. We use a standard model, in which a set of processes ùëù , . . . , ùëù 1 ùëõ , communicate through a shared memory consisting of base objects . The base objects are accessed with primitive operations . In addition to atomic reads and writes, our implementations use two additional standard synchronization primitives: compare &amp; swap ( ùëÖ, ùëúùëôùëë, ùëõùëíùë§ ) atomically compares the current value of ùëÖ with ùëúùëôùëë and if they are equal, replaces the current value of ùëÖ with ùëõùëíùë§ ; fetch &amp; xor ( ùëÖ, ùëéùëüùëî ) atomically replaces the current value of ùëÖ with a bitwise XOR of the current value and ùëéùëüùëî . 1

An implementation of a (high-level) object ùëá specifies a program for each process and each operation of the object ùëá ; when receiving an invocation of an operation, the process takes steps according to this program. Each step by a process consists of some local computation, followed by a single primitive operation on the shared memory. The process may change its local state after a step, and it may return a response to the operation of the high-level object.

Implemented (high-level) operations are denoted with capital letters, e.g., read, write, audit, while primitives applied to base objects, appear in normal font, e.g., read and write.

A configuration ùê∂ specifies the state of every process and of every base object. An execution ùõº is an alternating sequence of configurations and events, starting with an initial configuration ; it can be finite or infinite. For an execution

1 fetch &amp; xor is part of the ISO C++ standard since C++11 [9].

ùõº and a process ùëù ùõº , | ùëù is the projection of ùõº on events by ùëù . For two executions ùõº and ùõΩ , we write ùõº ùëù ‚àº ùõΩ when ùõº | ùëù = ùõΩ | ùëù , and say that ùõº and ùõΩ are indistinguishable to process ùëù .

An operation ùëúùëù completes in an execution ùõº if ùõº includes both the invocation and response of ùëúùëù ; if ùõº includes the invocation of ùëúùëù , but no matching response, then ùëúùëù is pending . An operation ùëúùëù precedes another operation ùëúùëù ‚Ä≤ in ùõº if the response of ùëúùëù appears before the invocation of ùëúùëù ‚Ä≤ in ùõº .

A history ùêª is a sequence of invocation and response events; no two events occur at the same time. The notions of complete , pending and preceding operations extend naturally to histories.

The standard correctness condition for concurrent implementations is linearizability [15]: intuitively, it requires that each operation appears to take place instantaneously at some point between its invocation and its response. Formally:

Definition 1. Let A be an implementation of an object ùëá . An execution ùõº of A is linearizable if there is a sequential execution ùêø (a linearization of the operations on ùëá in ùõº ) such that:

- ¬∑ ùêø contains all complete operations in ùõº , and a (possibly empty) subset of the pending operations in ùõº (completed with response events),
- ¬∑ If an operation ùëúùëù precedes an operation ùëúùëù ‚Ä≤ in ùõº , then ùëúùëù appears before ùëúùëù ‚Ä≤ in ùêø , and
- ¬∑ ùêø respects the sequential specification of the high-level object.

A is linearizable if all its executions are linearizable.

An implementation is lock-free if, whenever there is a pending operation, some operation returns in a finite number of steps of all processes. Finally, an implementation is wait-free if, whenever there is a pending operation by process ùëù , this operation returns in a finite number of steps by ùëù .

Auditable objects. An auditable register supports, in addition to the standard read and write operations, also an audit operation that reports which values were read by each process. Formally, an audit has no parameters and it returns a set of pairs, ( ùëó, ùë£ ) , where ùëó is a process id, and ùë£ is a value of the register. A pair ( ùëó, ùë£ ) indicates that process ùëù ùëó has read the value ùë£ .

Formally, the sequential specification of an auditable register enforces, in addition to the requirement on read and write operations, that a pair appears in the set returned by an audit operation if and only if it corresponds to a preceding read operation. In prior work [5], this if and only if property was stated as a combination of two properties of the sequential execution: accuracy , if a read is in the response set of the audit, then the read is before the audit (the only if part), and completeness , any read before the audit is in its response set (the if part).

We wish to capture in a precise, implementation-agnostic manner, the notion of an effective operation , which we will use to ensure that an audit operation will report all effective operations. Assume an algorithm A that implements an object ùëá . The next definition characterizes, in an execution in which a process ùëù invokes an operation, a point at which ùëù knows the value that the operation returns, even if the response event is not present.

Definition 2 (effective operation) . An operation ùëúùëù on object ùëá by process ùëù is ùë£ -effective after a finite execution prefix ùõº if, for every execution prefix ùõΩ indistinguishable from ùõº to ùëù (i.e., such that ùõº ùëù ‚àº ùõΩ ), ùëúùëù returns ùë£ in every extension ùõΩ ‚Ä≤ of ùõΩ in which ùëúùëù completes.

Observe that in this definition, ùõº itself is also trivially an execution prefix indistinguishable to ùëù , and hence in any extension ùõº ‚Ä≤ in which ùëúùëù completes returns value ùë£ . Observe as well that ùëúùëù could already be completed in ùõº or not be invoked (yet). However, the most interesting case is when ùëúùëù is pending in ùõº .

We next define the property that an operation on ùëá is not compromised in an execution prefix by a process. As we will see, in our register algorithm, a read by ùëù is linearized as soon as it becomes ùë£ -effective, in a such way that in any extension including a complete audit, ùëù is reported as a reader of ùë£ by this audit. This, however, does not prevent a curious reader ùëù from learning another value ùë£ ‚Ä≤ for which none of its read operations is ùë£ ‚Ä≤ -effective. In such a situation, the write operation with input ùë£ ‚Ä≤ is said to be compromised by ùëù . The next definition states that this can happen only if a read operation by ùëù becomes ùë£ ‚Ä≤ -effective. The definition is general, and applies to any object.

Definition 3 (uncompromised operation) . Consider a finite execution prefix ùõº and an operation ùëúùëù by process ùëû whose invocation is in ùõº . We say that ùëúùëù is uncompromised in ùõº by process ùëù if there is another finite execution ùõΩ such that ùõº ùëù ‚àº ùõΩ and ùëúùëù is not invoked in ùõΩ .

Avalue ùë£ is uncompromised by a reader ùëù if all write( ùë£ ) operations are uncompromised by ùëù , unless ùëù has an effective read returning ùë£ .

One-time pads. To avoid data leakage, we employ one-time pads [17, 19]. Essentially, a one-time pad is a random string-known only to the writers and auditors-with a bit for each reader. To encrypt a message ùëö ùëö , is bitwise XORed with the pad obtaining a ciphertext ùëê . Our algorithm relies on an infinite sequence of one-time pads. A one-time pad is additively malleable , i.e., when ùëì is an additive function, it is possible to obtain a valid encryption of ùëì ( ùëö ) by applying a corresponding function ùëì ‚Ä≤ to the ciphertext ùëê corresponding to ùëö .

Attacks. We consider an honest-but-curious (aka, semi-honest and passive) [13] attacker that interacts with the implementation of ùëá by performing operations, and adheres to its code. It may however stop prematurely and perform arbitrary local computations on the responses obtained from base objects. For instance, for an auditable register, the attacker can attempt to infer in a read operation the current or a past value of the register, without being reported in audit operations.

## 3 AN AUDITABLE MULTI-WRITER, MULTI-READER REGISTER

We present a wait-free and linearizable implementation of a multi-writer, multi-reader register (Alg. 1), in which effective reads are auditable. Furthermore, the implementation does not compromise other reads, as while performing a read operation, a process is neither able to learn previous values, nor whether some other process has read the current value. We ensure that a read operation is linearized as soon as, and not before it becomes effective. Audits hence report exactly those reads that have made enough progress to infer the current value of the register. As a consequence, the implementation is immune to an honest-but-curious attacker.

## 3.1 Description of the Algorithm

The basic idea of the implementation is to store in a single register ùëÖ , the current value and a sequence number, as well as the set of its readers, encoded as a bitset. Past values, as well as their reader set, are stored in other registers (arrays ùëâ and ùêµ in the code, indexed by sequence numbers), so auditors can retrieve them. Changing the current value from ùë£ to ùë§ consists in first copying ùë£ and its reader set to the appropriate registers ùëâ ùë† [ ] and ùêµ ùë† [ ] , respectively (where ùë† is ùë£ 's sequence number), before updating ùëÖ to a triple formed by ùë§ , a new sequence number, and an empty reader set. This is done with a compare &amp; swap in order not to miss changes to the reader set occurring between the copy and the update. An auditor starts by reading ùëÖ , obtaining the current value ùë§ , its set of readers, and its sequence number ùë† . Then it goes over arrays ùêµ and ùëâ to retrieve previous values written and the processes that have read them.

In an initial design of the implementation, a read operation obtains from ùëÖ the current value ùë£ and the reader set, adding locally the ID of the reader to this set before writing it back to ùëÖ , using compare &amp; swap . This simple design is easy to linearize (each operation is linearized with a compare &amp; swap or a read applied to ùëÖ ). However, besides the fact that read and write are only lock-free, this design has two drawbacks regarding information leaking:

First , a reader can read the current value without being reported by audit operations, simply by not writing to the memory after reading ùëÖ , when it already knows the current value ùë£ of the register. This step does not modify the state of ùëÖ (nor of any other shared variables), and it thus cannot be detected by any other operation. Therefore, by following its code, but pretending to stop immediately after accessing ùëÖ , a reader is able to know the current value without ever being reported by audit operations.

Second , each time ùëÖ is read by some process ùëù , it learns which readers have already read the current value. Namely, while performing a read operation, a process can compromise other reads.

Alg. 1 presents the proposed implementation of an auditable register. We deflect the 'crash-simulating' attack by having each read operation apply at most one primitive to ùëÖ that atomically returns the content of ùëÖ and updates the reader set. To avoid partial auditing, the reader set is encrypted, while still permitting insertion by modifying the encrypted set (i.e., a light form of homomorphic encryption.). Inserting the reader ID into the encrypted set should be kept simple, as it is part of an atomic modification of ùëÖ . We apply to the reader set a simple cipher (the one-time pad [17, 19]), and benefit from its additive malleability. Specifically, the IDs of the readers of the current value are tracked by the last ùëö bits of ùëÖ , where ùëö is the number of readers. When a new value with sequence number ùë† is written in ùëÖ , these bits are set to a random ùëö -bit string, rand ùë† , only known by writers and auditors. This corresponds to encrypting the empty set with a random mask. Process ùëù ùëñ is inserted in the set by XORing the ùëñ th tracking bit with 1. Therefore, retrieving the value stored in ùëÖ and updating the reader set can be done atomically by applying fetch &amp; xor . Determining set-membership requires the mask rand ùë† , known only to auditors and writers.

The one-time pad, as its name indicates, is secure as long as each mask is used at most once. This means we need to make sure that different sets encrypted with the same mask rand ùë† are never observed by a particular reader, otherwise, the reader may infer some set member by XORing the two ciphered sets. To ensure that, we introduce an additional register SN , which stores only the sequence number of the current value. A read operation by process ùëù ùëñ starts by reading SN , and, if it has not changed since the previous read by the same process, immediately returns the latest value read. Otherwise, ùëù ùëñ obtains the current value ùë£ and records itself as one of its readers by applying a fetch &amp; xor (2 ) ùëñ operation to ùëÖ . This changes the ùëñ th tracking bit, leaving the rest of ùëÖ intact. Finally, ùëù ùëñ updates SN to the current sequence number read from ùëÖ , thus ensuring that ùëù ùëñ will not read ùëÖ again, unless its sequence number field is changed. This is done with a compare &amp; swap to avoid writing an old sequence number in ùëÜùëÅ .

Writing a new value ùë§ requires retrieving and storing the IDs of the readers of the current value ùë£ for future audit, writing ùë§ , the new sequence number ùë† + 1, and an empty reader set encrypted with a fresh mask rand ùë† + 1 to ùëÖ before announcing the new sequence number in SN . To that end, ùëù ùëó first locally gets a new sequence number ùë† + 1, where ùë† is read from ùëÜùëÅ . It then repeatedly reads ùëÖ , deciphers the tracking bits and updates shared registers ùëâ ùë† [ ] and ùêµ ùë† [ ] accordingly until it succeeds in changing it to ( ùë† + 1 , ùë§, rand ùë† + 1 ) or it discovers a sequence number ùë† ‚Ä≤ ‚â• ùë† + 1 in ùëÖ . In the latter case, a concurrent write( ùë§ ‚Ä≤ ) has succeeded, and may be seen as occurring immediately after ùëù ùëó 's operation, which therefore can be abandoned. In the absence of a concurrent write, the compare &amp; swap applied to ùëÖ may fail as the tracking bits are modified by a concurrent read. This happens at most ùëö times, as each reader applies at most one fetch &amp; xor to ùëÖ while its sequence number field does not change. Whether or not ùëù ùëó succeeds in modifying ùëÖ , we make

sure that before write( ùë§ ) terminates, the sequence number ùëÜùëÅ is at least as large as the new sequence number ùë† + 1. In this way, after that, write operations overwrite the new value ùë§ and read operations return ùë§ or a more recent value.

Because SN and ùëÖ are not updated atomically, their sequence number fields may differ. In fact, an execution of Alg. 1 alternates between normal ùê∏ phases, in which both sequence numbers are equal , and transition ùê∑ phases in which they differ . A transition phase is triggered by a write( ùë§ ) with sequence number ùë† and ends when the write completes or it is helped to complete by updating ùëÜùëÅ to ùë† . Care must be taken during a ùê∑ phase, as some read, which is silent , may return the old value ùë£ , while another, direct , read returns the value ùë§ being written. For linearization, we push back silent read before the compare &amp; swap applied to ùëÖ that marks the beginning of phase ùê∑ , while a direct read is linearized with its fetch &amp; xor applied to ùëÖ .

An audit starts by reading ùëÖ , thus obtaining the current value ùë£ , and its sequence number ùë† ; it is linearized with this step. It then returns the set of readers for ùë£ (inferred from the tracking bits read from ùëÖ ) as well as for each previously written value (which can be found in the registers ùëâ ùë† [ ‚Ä≤ ] and ùêµ ùë† [ ‚Ä≤ ] , for ùë† ‚Ä≤ &lt; ùë† .). In a ùê∑ phase, a silent read operation may start after an audit reads ùëÖ while being linearized before this step, so we make sure that the ùê∑ phase ends before the audit returns. This is done, as in direct read and write, by making sure that SN is at least as large as the sequence number ùë† read from ùëÖ . In this way, a silent read (this also holds for a write that is immediately overwritten) whose linearization point is pushed back before that of an audit is concurrent with this audit, ensuring that the linearization order respects the real time order between these operations.

Suppose that an audit by some process ùëù ùëñ reports ùëù ùëó as a reader of some value ùë£ . This happens because ùëù ùëñ directly identifies ùëù ùëó as a reader of ùë£ from the tracking bits in ùëÖ , or indirectly by reading the registers ùëâ ùë† [ ] and ùêµ ùë† [ ] , where ùëâ ùë† [ ] = ùë£ . In both cases, in a read instance ùëúùëù , reader ùëù ùëó has previously applied a fetch &amp; xor to ùëÖ while its value field is ùë£ . Since the response of this fetch &amp; xor operation completely determines the return value of ùëúùëù , independently of future or past steps taken by ùëù ùëó , ùëúùëù is effective. Therefore, only effective operations are reported by audit, and if an audit that starts after ùëúùëù is effective, it will discover that ùëù ùëó read ùë£ , again either directly in the tracking bits of ùëÖ , or indirectly after the reader set has been copied to ùêµ ùë† [ ] .

## 3.2 Proof of Correctness

Partitioning into phases. We denote by ùëÖ.ùë†ùëíùëû, ùëÖ.ùë£ùëéùëô and ùëÖ.ùëèùëñùë°ùë† the sequence number, value and ùëö -bits string, respectively, stored in ùëÖ . We start by observing that the pair of values in ( ùëÖ.ùë†ùëíùëû, ùëÜùëÅ ) takes on the following sequence: ( 0 0 , ) , ( 1 0 , ) , ( 1 1 , ) , . . . , ( ùë•, ùë• -1 ) , ( ùë•, ùë• ) , . . . Indeed, when the state of the implemented register changes to a new value ùë£ , this value is written to ùëÖ together with a sequence number ùë• + 1, where ùë• is the current value of ùëÜùëÅ . ùëÜùëÅ is then updated to ùë• + 1, and so on.

Initially, ( ùëÖ.ùë†ùëíùëû, ùëÜùëÅ ) = ( 0 0 . By invariants that can be proved on the algorithm, the successive values of , ) ùëÖ.ùë†ùëíùëû and ùëÜùëÅ are 0 1 2 , , , . . . , ùëÜùëÅ ‚â• ùë• -1 when ùëÖ.ùë†ùëíùëû is changed to ùë• , and when ùëÜùëÅ is changed to ùë• , ùëÖ.ùë†ùëíùëû has previously been updated to ùë• . Therefore, the sequence of successive values of the pair ( ùëÖ.ùë†ùëíùëû, ùëÜùëÅ ) is ( 0 0 , ) , ( 1 0 , ) , ( 1 1 , ) , . . . , ( ùë•, ùë• -1 ) , ( ùë•, ùë• ) , . . . . We can therefore partition any execution into intervals ùê∏ ùë• and ùê∑ ùë• (for ùê∏ qual and ùê∑ ifferent), so that ùëÖ.ùë†ùëíùëû = ùë• and ùëÜùëÅ = ùë• during ùê∏ ùë• , and ùëÖ.ùë†ùëíùëû = ùë• and ùëÜùëÅ = ùë• -1 during ùê∑ ùë• :

Lemma 1. A finite execution ùõº can be written, for an integer ùëò ‚â• 0 , either as ùê∏ ùúå ùê∑ ùúé ùê∏ 0 1 1 1 1 . . . ùúå ùëò ùê∑ ùúé ùê∏ ùëò ùëò ùëò or as ùê∏ ùúå ùê∑ ùúé ùê∏ 0 1 1 1 1 . . . ùúé ùëò -1 ùê∏ ùëò -1 ùúå ùëò ùê∑ ùëò , where:

## Algorithm 1 Multi-writer, ùëö -reader auditable register implementation

## shared registers:

R : a register supporting read , compare &amp; swap , and fetch &amp; xor , initially ( 0 , ùë£ 0 , rand 0 )

SN : a register supporting read and compare &amp; swap ,

- initially 0

ùëâ [ 0 .. + ‚àû] registers, initially [‚ä• , . . . , ‚ä•]

ùêµ [ 0 .. + ‚àû][ 0 ..ùëö -1 ] Boolean registers, initially,

ùêµ ùë†, ùëó [ ] = false for every ( ùë†, ùëó ) : ùë† ‚â• 0 0 , ‚â§ ùëó &lt; ùëö .

## local variables: reader

ùëùùëüùëíùë£ \_ ùë£ùëéùëô, ùëùùëüùëíùë£ \_ ùë†ùëõ : latest value read ( ‚ä• initially) and its sequence number ( -1 initially)

## local variables common to writers and auditors

rand 0 , rand 1 , . . . : sequence of random ùëö -bit strings

## local variables: auditor

ùê¥ : audit set, initially ‚àÖ ;

ùëôùë†ùëé : latest 'audited' seq. number, initially 0

- 1: function read( )
- 2: ùë†ùëõ ‚Üê SN . read ()
- 3: if ùë†ùëõ = ùëùùëüùëíùë£ \_ ùë†ùëõ then return ùëùùëüùëíùë£ \_ ùë£ùëéùëô
- 4: ( ùë†ùëõ, ùë£ùëéùëô, \_ ) ‚Üê ùëÖ. fetch &amp; xor ( 2 ùëó )
- 5: ùëÜùëÅ. compare &amp; swap ( ùë†ùëõ -1 , ùë†ùëõ )
- 6:
- ùëùùëüùëíùë£ \_ ùë†ùëõ ‚Üê ùë†ùëõ ; ùëùùëüùëíùë£ \_ ùë£ùëéùëô ‚Üê ùë£ùëéùëô ; return ùë£ùëéùëô

7:

8:

9:

10:

11:

12:

13:

function write( )

ùë£

ùë†ùëõ ‚Üê SN . read () + 1

repeat

( ùëôùë†ùëõ, ùëôùë£ùëéùëô, ùëèùëñùë°ùë† ) ‚Üê ùëÖ. read ()

if

ùëôùë†ùëõ

‚â•

ùë†ùëõ

then break

ùëâ ùëôùë†ùëõ .

[

]

write

(

ùëôùë£ùëéùëô

)

;

for each ùëó : ùëèùëñùë°ùë† [ ùëó ] ‚â† rand ùëôùë†ùëõ [ ùëó ] do

ùêµ ùëôùë†ùëõ [ ] [ ùëó ] . write ( ùë°ùëüùë¢ùëí )

14: until ùëÖ. compare &amp; swap (( ùëôùë†ùëõ, lval , ùëèùëñùë°ùë† ) , ( ùë†ùëõ, ùë£, rand ùë†ùëõ ))

15:

ùëÜùëÅ.

compare

&amp;

swap

(

ùë†ùëõ

-

1

, ùë†ùëõ

)

;

return

16:

function audit( )

17: ( ùëüùë†ùëõ, ùëüùë£ùëéùëô, ùëüùëèùëñùë°ùë† ) ‚Üê ùëÖ. read ()

18:

for

ùë†

=

ùëôùë†ùëé, ùëôùë†ùëé

+

1

, . . . , ùëüùë†ùëõ

-

19: ùë£ùëéùëô ‚Üê ùëâ ùë† . [ ] read () ;

20:

ùê¥

‚Üê

ùê¥

‚à™ {(

ùëó, ùë£ùëéùëô

)

:

0

‚â§

ùëó

&lt;

ùëö, ùêµ ùë†

[

] [

ùëó

]

.

read

()

=

true

- 21: ùê¥ ‚Üê ùê¥ ‚à™ {( ùëó, ùëüùë£ùëéùëô ) : 0 ‚â§ ùëó &lt; ùëö,ùëèùëñùë°ùë† [ ùëó ] ‚â† rand ùëüùë†ùëõ [ ùëó ]}

22: ùëôùë†ùëé ‚Üê ùë†ùëõ ; ùëÜùëÅ. compare &amp; swap ( ùëüùë†ùëõ -1 , ùëüùë†ùëõ ) ; return ùê¥

- ¬∑ ùúå ‚Ñì and ùúé ‚Ñì are the steps that respectively change the value of ùëÖ.ùë†ùëíùëû and ùëÜùëÅ from ‚Ñì -1 to ‚Ñì ( ùúå ‚Ñì is a successful ùëÖ. compare &amp; swap , line 14, ùúé ‚Ñì is also a successful SN . compare &amp; swap , applied within a read, line 5, a write, line 15, or an audit, line 22).
- ¬∑ in any configuration in ùê∏ ‚Ñì , ùëÖ.ùë†ùëíùëû = ùëÜùëÅ = ‚Ñì , and in any configuration in ùê∑ ‚Ñì , ùëÖ.ùë†ùëíùëû = ‚Ñì = ùëÜùëÅ + 1 .

1

do

‚ä≤ store a triple (sequence number, value, ùëö -bits string)

‚ä≤ code for reader ùëù ùëó , 0 ‚â§ ùëó &lt; ùëö

‚ä≤ no new write since latest read operation

‚ä≤ fetch current value and insert ùëó in reader set ‚ä≤ help complete ùë†ùëõ th write

‚ä≤ code for writer ùëù , ùëñ ùëñ ‚àâ { 0 , . . . , ùëö -1 }

}

## Auditing without Leaks Despite Curiosity

Termination. It is clear that audit and read operations are wait-free. We prove that write operations are also wait-free, by showing that the repeat loop (lines 9-14) terminates after at most ùëö + 1 iterations. This holds since each reader may change ùëÖ at most once (by applying a ùëÖ. fetch &amp; xor , line 4) while ùëÖ.ùë†ùëíùëû remains the same.

## Lemma 2. Every operation terminates within a finite number of its own steps.

Proof sketch. The lemma clearly holds for read and audit operations. Let ùë§ùëúùëù be a write operation, and assume, towards a contradiction, that it does not terminate. Let ùë†ùëõ = ùë• + 1 be the sequence number obtained at the beginning of ùë§ùëúùëù at line 8, where ùë• is the value read from ùëÜùëÅ . We denote by ( ùë†ùëü, ùë£ùëü, ùëèùëü ) the triple read from ùëÖ in the first iteration of the repeat loop. It can be shown that ùë• ‚â§ ùë†ùëü . As ùë†ùëü &lt; ùë†ùëõ = ùë• + 1 (otherwise the loop breaks in the first iteration at line 11, and the operation terminates), we have ùë†ùëü = ùë• .

As ùë§ùëúùëù does not terminate, in particular the compare &amp; swap applied to ùëÖ at the end of the first iteration fails. Let ( ùë†ùëü ‚Ä≤ , ùë£ùëü ‚Ä≤ , ùëèùëü ‚Ä≤ ) be the value of ùëÖ immediately before this step is applied. This can be used to show that if ùë†ùëü ‚Ä≤ ‚â† ùë†ùëü or ùë£ùëü ‚Ä≤ ‚â† ùë£ùëü , then ùë†ùëü ‚Ä≤ &gt; ùë†ùëü . Therefore, ùë§ùëúùëù terminates in the next iteration as the sequence number read from ùëÖ in that iteration is greater than or equal to ùë†ùëõ (line 11). It thus follows that ùë†ùëü = ùë†ùëü ‚Ä≤ , ùë£ùëü = ùë£ùëü ‚Ä≤ , and ùëèùëü ‚â† ùëèùëü ‚Ä≤ : at least one reader applies a fetch &amp; xor to ùëÖ during the first iteration of repeat loop.

The same reasoning applies to the next iterations of the repeat loop. In each of them, the sequence number and the value stored in ùëÖ are the same, ùë†ùëü and ùë£ùëü respectively (otherwise the loop would break at line 11), and thus a reader applies a fetch &amp; xor to ùëÖ before the compare &amp; swap of line 14 (otherwise the compare &amp; swap succeeds and ùë§ùëúùëù terminates). But it can be shown that each reader applies at most one fetch &amp; xor to ùëÖ while it holds the same sequence number, which is a contradiction. ‚ñ°

Linearizability. Let ùõº be a finite execution, and ùêª be the history of the read, write, and audit operations in ùõº . We classify and associate a sequence number with some of read and write operations in ùêª as explained next. Some operations that did not terminate are not classified, and they will later be discarded.

- ¬∑ A read operation ùëúùëù is silent if it reads ùë• = ùëùùëüùëíùë£ \_ ùë†ùëõ at line 2. The sequence number ùë†ùëõ ùëúùëù ( ) associated with a silent read operation ùëúùëù is the value ùë• returned by the read from SN . Otherwise, if ùëúùëù applies a fetch &amp; xor to ùëÖ , it is said to be direct . Its sequence number ùë†ùëõ ùëúùëù ( ) is the one fetched from ùëÖ (line 4).
- ¬∑ Awrite operation ùëúùëù is visible if it applies a successful compare &amp; swap to ùëÖ (line 14). Otherwise, if ùëúùëù terminates without applying a successful compare &amp; swap on ùëÖ (by exiting the repeat loop from the break statement, line 11), it is said to be silent . For both cases, the sequence number ùë†ùëõ ùëúùëù ( ) associated with ùëúùëù is ùë• + 1, where ùë• is the value read from ùëÜùëÅ at the beginning of ùëúùëù (line 8).

Note that all terminated read or write operations are classified as silent, direct, or visible. An audit operation ùëúùëù is associated with the sequence number read from ùëÖ at line 17.

We define a complete history ùêª ‚Ä≤ by removing or completing the operations that do not terminate in ùõº , as follows: Among the operations that do not terminate, we remove every audit and every unclassified read or write. For a silent read that does not terminate in ùõº , we add a response immediately after SN is read at line 2. The value returned is ùëùùëüùëíùë£ \_ ùë£ùëéùëô , that is the value returned by the previous read by the same process. For each direct read operation ùëúùëù that does not terminate in ùõº , we add a response with value ùë£ defined as follows. Since ùëúùëù is direct, it applies a fetch &amp; xor on ùëÖ that returns a triple ( ùë†ùëü, ùë£ùëü, ùëèùëü ) ; ùë£ is the value ùë£ùëü in that triple. In ùêª ‚Ä≤ , we place the response of non-terminating direct read and visible write after every response and every remaining invocation of ùêª , in an arbitrary order.

Finally, to simplify the proof, we add at the beginning of ùêª ‚Ä≤ an invocation immediately followed by a response of a write operation with input ùë£ 0 (the initial value of the auditable register.). This fictitious operation has sequence number 0 and is visible.

Essentially, in the implemented register updating to a new value ùë£ is done in two phases. ùëÖ is first modified to store ùë£ and a fresh sequence number ùë• + 1, and then the new sequence number is announced in ùëÜùëÅ . Visible write, direct read, and audit operations may be linearized with respect to the compare &amp; swap fetch , &amp; xor or read they apply to ùëÖ . Special care should be taken for silent read and write operations. Indeed, a silent read that reads ùë• from ùëÜùëÅ , may return the previous value ùë¢ stored in the implemented register or ùë£ , depending on the sequence number of the last preceding direct read by the same process. Similarly, a silent write( ùë£ ‚Ä≤ ) may not access ùëÖ at all, or apply a compare &amp; swap after ùëÖ.ùë†ùëíùëû has already been changed to ùë• + 1. However, write( ùë£ ‚Ä≤ ) has to be linearized before write( ùë£ ), in such a way that ùë£ ‚Ä≤ is immediately overwritten.

Hence, direct read, visible write, and audit are linearized first, according to the order in which they apply a primitive to ùëÖ . We then place the remaining operations with respect to this partial linearization. ùêø ùõº ( ) is the total order on the operations in ùêª ‚Ä≤ obtained by the following rules:

- R1 For direct read, visible write, audit and some silent read operations we defined an associated step ùëôùë† applied by the operation. These operations are then ordered according to the order in which their associated step takes place in ùõº . For a direct read, visible write, or audit operation ùëúùëù , its associated step ùëôùë† ( ùëúùëù ) is respectively the fetch &amp; xor at line 4, the successful compare &amp; swap at line 14, and the read at line 17 applied to ùëÖ . For a silent read operation ùëúùëù with sequence number ùë†ùëõ ùëúùëù ( ) = ùë• , if ùëÜùëÅ. read (line 2) is applied in ùëúùëù during ùê∏ ùë• (that is, ùëÖ.ùë†ùëíùëû = ùë• when this read occurs), ùëôùë† ( ùëúùëù ) is this read step. The other silent read operations do not have a linearization step, and are not ordered by this rule. They are instead linearized by Rule R2.

Recall that ùúå ùë• + 1 is the successful compare &amp; swap applied to ùëÖ that changes ùëÖ.ùë†ùëíùëû from ùë• to ùë• + 1 (Lemma 1). By rule R1, the visible write with sequence number ùë• + 1 is linearized at ùúå ùë• + 1 .

- R2 For every ùë• ‚â• 0, every remaining silent read ùëúùëù with sequence number ùë†ùëõ ùëúùëù ( ) = ùë• is placed immediately before the unique visible write operation with sequence number ùë• + 1. Their relative order follows the order in which their read step of ùëÜùëÅ (line 2) is applied in ùõº .
- R3 Finally, we place for each ùë• ‚â• 0 every silent write operation ùëúùëù with sequence number ùë†ùëõ ùëúùëù ( ) = ùë• + 1. They are placed after the silent read operations with sequence number ùë• ordered according to rule R2, and before the unique visible write operation with sequence number ùë• + 1. As above, their respective order is determined by the order in which their read step of ùëÜùëÅ (line 8) is applied in ùõº .

Rules R2 and R3 are well-defined, is we can prove the existence and uniqueness of a visible write with sequence number ùë• , if there is an operation ùëúùëù with ùë†ùëõ ùëúùëù ( ) = ùë• .

We can show that the linearization ùêø ùõº ( ) extends the real-time order between operations, and that the read and write operations satisfy the sequential specification of a register.

Audit Properties. For the rest of the proof, fix a finite execution ùõº . The next lemma helps to show that effective operations are audited; it demonstrates how indistinguishability is used in our proofs.

Lemma 3. A read operation ùëüùëúùëù that is invoked in ùõº is in ùêø ùõº ( ) if and only if ùëüùëúùëù is effective in ùõº .

Proof. If ùëüùëúùëù completes in ùõº , then it is effective and it is in ùêø ùõº ( ) . Otherwise, ùëüùëúùëù is pending after ùõº . Let ùëù ùëó be the process that invokes ùëüùëúùëù . We can show:

## Claim 4. ùëüùëúùëù is effective after ùõº if and only if either

(1) ùëù ùëó has read ùë• from SN and ùë• = ùëùùëüùëíùë£ \_ ùë†ùëõ (line 2) or

(2) ùëù ùëó has applied fetch &amp; xor to ùëÖ (line 4).

Proof. First, let ùõº ‚Ä≤ be an arbitrary extension of ùõº in which ùëüùëúùëù returns some value ùëé , ùõΩ a finite execution indistinguishable from ùõº to ùëù ùëó , and ùõΩ ‚Ä≤ one of its extensions in which ùëüùëúùëù returns some value ùëè . We show that if ùõº satisfies (1) or (2), then ùëé = ùëè . (1) If in ùõº after invoking ùëüùëúùëù , ùëù ùëó reads ùë• = ùëùùëüùëíùë£ \_ ùë†ùëõ from SN at line 2, then ùëüùëúùëù returns ùëé = ùëùùëüùëíùë£ \_ ùë£ùëéùëô in ùõº ‚Ä≤ . Since ùõº ùëù ùëó ‚àº ùõΩ , ùëùùëüùëíùë£ \_ ùë£ùëéùëô = ùëé and ùëùùëüùëíùë£ \_ ùë†ùëõ = ùë• when ùëüùëúùëù starts in ùõΩ , and ùëù ùëó reads also ùë• from ùëÜùëÅ . Therefore, ùëüùëúùëù returns ùëè = ùëé in ùõΩ ‚Ä≤ . (2) If ùëù ùëó applies a fetch &amp; xor to ùëÖ (line 4) while performing ùëüùëúùëù in ùõº , then ùëüùëúùëù returns ùëé = ùë£ (line 6), where ùë£ is the value fetched from ùëÖ.ùë£ùëéùëô in ùõº ‚Ä≤ . Since ùõº ùëù ùëó ‚àº ùõΩ , ùëù ùëó also applies a fetch &amp; xor to ùëÖ while performing ùëüùëúùëù in ùõΩ , and fetches ùë£ from ùëÖ.ùë£ùëéùëô . Therefore ùëüùëúùëù also returns ùë£ in ùõΩ ‚Ä≤ .

Conversely, suppose that neither (1) nor (2) hold for ùõº . That is, ùëù ùëó has not applied a fetch &amp; xor to ùëÖ and, if ùë• has been read from SN , ùë• ‚â† ùëùùëüùëíùë£ \_ ùë†ùëõ . We construct two extensions ùõº ‚Ä≤ and ùõº ‚Ä≤‚Ä≤ in which ùëüùëúùëù returns ùë£ ‚Ä≤ ‚â† ùë£ ‚Ä≤‚Ä≤ , respectively. Let ùëã be the value of ùëÜùëÅ at the end of ùõº , and ùëù ùëñ be a writer. In ùõº ‚Ä≤ , ùëù ùëñ first completes its pending write if it has one, before repeatedly writing the same value ùë£ ‚Ä≤ until performing a visible write( ùë£ ‚Ä≤ ). Finally, ùëù ùëó completes ùëüùëúùëù . Since ùëù ùëñ is the only writer that takes steps in ùõº , it eventually has a visible write( ùë£ ‚Ä≤ ), that is in which ùëÖ.ùë£ùëéùëô is changed to ùë£ ‚Ä≤ . Note also that when this happens, SN &gt; ùëã . The extension ùõº ‚Ä≤‚Ä≤ is similar, except that ùë£ ‚Ä≤ is replaced by ùë£ ‚Ä≤‚Ä≤ .

Since conditions (1) and (2) do not hold, ùëù ùëñ 's next step in ùëüùëúùëù is reading ùëÜùëÅ or issuing ùëÖ. fetch &amp; xor . If ùëù ùëó reads ùëÜùëÅ after resuming ùëüùëúùëù , it gets a value ùë• &gt; ùëùùëüùëíùë£ \_ ùë£ùëéùëô . Thus, in both cases, ùëù ùëó accesses ùëÖ in which it reads ùëÖ.ùë£ùëéùëô = ùë£ ‚Ä≤ (or ùëÖ.ùë£ùëéùëô = ùë£ ‚Ä≤‚Ä≤ ). Therefore, ùëüùëúùëù returns ùë£ ‚Ä≤ in ùõº ‚Ä≤ and ùë£ ‚Ä≤‚Ä≤ in ùõº ‚Ä≤‚Ä≤ . ‚ñ°

Now, if (1) holds ( ùëù ùëó reads ùë• = ùëùùëüùëíùë£ \_ ùë£ùëéùëô from ùëÜùëÅ at line 2), then ùëüùëúùëù is classified as a silent read, and it appears in ùêø ùõº ( ) , by rule ùëÖ 1 if ùëÖ.ùë†ùëíùëû = ùë• when ùëÜùëÅ is read or rule ùëÖ 2, otherwise. If (2) holds ( ùëù ùëó applies a fetch &amp; xor to ùëÖ ), then ùëúùëù is a direct read, and linearized in ùêø ùõº ( ) by rule ùëÖ 1.

If neither (1) nor (2) hold, then ùëù ùëó has either not read ùëÜùëÅ , or read a value ‚â† ùëùùëüùëíùë£ \_ ùë£ùëéùëô from ùëÜùëÅ but without yet accessing ùëÖ . In both cases, ùëúùëù is unclassified and hence not linearized. ‚ñ°

We can prove that an audit ùëéùëúùëù includes a pair ( ùëó, ùë£ ) in its response set if and only if a read operation by process ùëù ùëó with output ùë£ is linearized before it. Since a read is linearized if and only it is effective (Lemma 3), any audit operation that is linearized after the read is effective, must report it. This implies:

Lemma 5. If an audit operation ùëéùëúùëù is invoked and returns in an extension ùõº ‚Ä≤ of ùõº , and ùõº contains a ùë£ -effective read operation by process ùëù ùëó , then ( ùëó, ùë£ ) is contained in the response set of ùëéùëúùëù .

Lemma 6 shows that writes are uncompromised by readers, namely, a read cannot learn of a value written, unless it has an effective read that returned this value. Lemma 7 shows that reads are uncompromised by other readers, namely, they do not learn of each other.

Lemma 6. Assume ùëù ùëó only performs read operations. Then for every value ùë£ either there is a read operation by ùëù ùëó in ùõº that is ùë£ -effective, or there is ùõº ‚Ä≤ , ùõº ‚Ä≤ ùëù ùëó ‚àº ùõº in which no write has input ùë£ .

Proof. If ùë£ is not an input of some write operation in ùõº , the lemma follows by taking ùõº ‚Ä≤ = ùõº . If there is no visible write( ) operation in ùë£ ùõº , then, since a silent write( ùë£ ) does not change ùëÖ.ùë£ùëéùëô to ùë£ , the lemma follows by changing its input to some value ùë£ ‚Ä≤ ‚â† ùë£ to obtain an execution ùõº ‚Ä≤ ùëù ùëó ‚àº ùõº

Let ùë§ùëúùëù be a visible write( ùë£ ) operation in ùõº . Since it is visible, ùë§ùëúùëù applies a compare &amp; swap to ùëÖ that changes ( ùëÖ.ùë†ùëíùëû, ùëÖ.ùë£ùëéùëô ) to ( ùë•, ùë£ ) where ùë• is some sequence number. If ùëù ùëó applies a fetch &amp; xor to ùëÖ while ùëÖ.ùë£ùëéùëô = ùë£ , then the corresponding read operation ùëüùëúùëù it is performing is direct and ùë£ -effective. Otherwise, ùëù ùëó never applies a fetch &amp; xor to ùëÖ while ùëÖ.ùë£ùëéùëô = ùë£ . ùëÖ is the only shared variable in which inputs of write are written and that is read by ùëù ùëó . Hence, the input of ùë§ùëúùëù can be replaced by another value ùë£ ‚Ä≤ ‚â† ùë£ , creating an indistinguishable execution ùõº ‚Ä≤ without a write with input ùë£ . ‚ñ°

Lemma 7. Assume ùëù ùëó only performs read operations, then for any reader ùëù ùëò , ùëò ‚â† ùëó , there is an execution ùõº ‚Ä≤ ùëù ùëó ‚àº ùõº in which no read by ùëù ùëò is ùë£ -effective, for any value ùë£ .

Proof. The lemma clearly holdes if there is no ùë£ -effective read by process ùëù ùëò . So, assume there is a ùë£ -effective read operation ùëüùëúùëù by ùëù ùëò . Let ùõº ‚Ä≤ be the execution in which we remove all ùë£ -effective read operations performed by ùëù ùëò that are silent. Such operations do not change any shared variables, and therefore, ùõº ‚Ä≤ ùëù ùëó ‚àº ùõº .

So, let ùëüùëúùëù be a direct, ùë£ -effective read by ùëù ùëò . When performing ùëüùëúùëù , ùëù ùëò applies fetch &amp; xor to ùëÖ (line 4), when ( ùëÖ.ùë†ùëíùëû, ùëÖ.ùë£ùëéùëô ) = ( ùë•, ùë£ ) , for some sequence number ùë• . This step only changes the ùëò th tracking bit of ùëÖ unchanged to, say, ùëè . Recall that ùëÖ is accessed (by applying a fetch &amp; xor ) at most once by ùëù ùëó while ùëÖ.ùë†ùëíùëû = ùë• . If no fetch &amp; xor by ùëù ùëó is applied to ùëÖ while ùëÖ.ùë†ùëíùëû = ùë• , or one is applied before ùëù ùëò 's, ùëüùëúùëù can be removed without being noticed by ùëù ùëó . Suppose that both ùëù ùëò and ùëù ùëó apply a fetch &amp; xor to ùëÖ while ùëÖ.ùë†ùëíùëû = ùë• , and that ùëù ùëó 's fetch &amp; xor is after ùëù ùëò 's. Let ùõº ‚Ä≤ ùë•,ùëè be the execution identical to ùõº ‚Ä≤ , except that (1) the ùëò th bit of ùëüùëéùëõùëë ùë• is ùëè and, (2) ùëüùëúùëù is removed. Therefore, ùõº ‚Ä≤ ùë•,ùëè ùëù ùëó ‚àº ùõº ‚Ä≤ , and since ùõº ‚Ä≤ ùëù ùëó ‚àº ùõº , we have that ùõº ‚Ä≤ ùë•,ùëè ùëù ùëó ‚àº ùõº . ‚ñ°

Theorem 8. Alg. 1 is a linearizable and wait-free implementation of an auditable multi-writer, multi-reader register. Moreover,

- ¬∑ An audit reports ( ùëó, ùë£ ) if and only if ùëù ùëó has an ùë£ -effective read operation in ùõº .
- ¬∑ a write is uncompromised by a reader ùëù ùëó , unless ùëù ùëó has a ùë£ -effective read.
- ¬∑ a read by ùëù ùëò is uncompromised by a reader ùëù ùëó ‚â† ùëù ùëò .

## 4 AN AUDITABLE MAX REGISTER

This section shows how to extend the register implementation of the previous section into an implementation of a max register with the same properties. A max register provides two operations: writeMax ( ùë£ ) which writes a value ùë£ and read which returns a value. Its sequential specification is that a read returns the largest value previously written. An auditable max register also provides an audit operation, which returns a set of pairs ( ùëó, ùë£ ) . As in the previous section, reads are audited if and only if they are effective, and readers cannot compromise other writeMax operations, unless they read them, or other read operations.

Alg. 2 uses essentially the same read and audit as in Alg. 1. The writeMax operation is also quite similar, with the following differences (lines in blue in the pseudo-code). In Alg. 1, a write( ùë§ ) obtains a new sequence number ùë† + 1 and then attempts to change ùëÖ to ( ùë† + 1 , ùë§, ùëüùëéùëõùëë ùë† + 1 ) . The operation terminates after it succeeds in doing so, or if it sees in ùëÖ a sequence number ùë† ‚Ä≤ ‚â• ùë† + 1. In the latter case, a concurrent write( ùë§ ‚Ä≤ ) has succeeded and may be seen as overwriting ùë§ , so write( ùë§ ) can terminate, even if ùë§ is never written to ùëÖ . The implementation of writeMax uses a similar idea, except that (1) we make sure that the successive values in ùëÖ are non-decreasing and (2) a writeMax( ùë§ ) with sequence number ùë† + 1 is no longer abandoned when a sequence number ùë† ‚Ä≤ ‚â• ùë† + 1 is read from ùëÖ , but instead when ùëÖ stores a value ùë§ ‚Ä≤ ‚â• ùë§ .

| Algorithm 2 Auditable Max Register   | Algorithm 2 Auditable Max Register                                                                                                                                                                  |
|--------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|                                      | shared registers ùëÖ, SN , ùëâ [ 0 .. + ‚àû] , ùêµ [ 0 .. + ‚àû][ 0 ..ùëö - 1 ] as in Alg. 1 ùëÄ : a (non-auditable) max register, initially ùë£ 0 = ( ùë§ 0 , local variables: writer, reader, auditor, as in Alg. 1 |
| 21:                                  | ùëÅ 0 ) read( ), audit( ): same as in Alg 1                                                                                                                                                           |
|                                      | function                                                                                                                                                                                            |
| 22:                                  | function writeMax( ùë§ )                                                                                                                                                                              |
| 23:                                  | ùë£ ‚Üê( ùë§, ùëÅ ) , where ùëÅ is a fresh random nonce                                                                                                                                                       |
| 24:                                  | ùëÄ. writeMax ( ùë£ ) ; ùë†ùëõ ‚Üê SN . read () + 1;                                                                                                                                                          |
| 25:                                  | repeat                                                                                                                                                                                              |
| 26:                                  | ( ùëôùë†ùëõ, ùëôùë£ùëéùëô, ùëèùëñùë°ùë† ) ‚Üê ùëÖ. read ()                                                                                                                                                                    |
| 27:                                  | if ùëôùë£ùëéùëô ‚â• ùë£ then ùë†ùëõ ‚Üê ùëôùë†ùëõ ; break                                                                                                                                                                   |
| 28:                                  | if ùëôùë†ùëõ ‚â• ùë†ùëõ then                                                                                                                                                                                    |
| 29:                                  | SN . compare & swap ( ùë†ùëõ - 1 , ùë†ùëõ ) ;                                                                                                                                                               |
| 30:                                  | ùë†ùëõ ‚Üê SN . read () + 1; continue                                                                                                                                                                     |
| 31:                                  | ùëöùë£ùëéùëô ‚Üê ùëÄ. read ()                                                                                                                                                                                   |
| 32:                                  | ùëâ [ ùëôùë†ùëõ ] . write ( ùëôùë£ùëéùëô.ùë£ùëéùëôùë¢ùëí ) ;                                                                                                                                                                  |
| 33:                                  | ùêµ [ ùëôùë†ùëõ ] [ ùëó ] . write ( true ) ‚àÄ ùëó , s.t. ùëèùëñùë°ùë† [ ùëó ] ‚â† ùëüùëéùëõùëë ùëôùë†ùëõ [ ùëó ]                                                                                                                             |
| 34:                                  | until ùëÖ. compare & swap (( ùëôùë†ùëõ, ùëôùë£ùëéùëô, ùëèùëñùë°ùë† ) , ( ùë†ùëõ,ùëöùë£ùëéùëô,ùëüùëéùëõùëë ùë†ùëõ                                                                                                                                    |
| 35:                                  | SN . compare & swap ( ùë†ùëõ - 1 , ùë†ùëõ ) ; return                                                                                                                                                        |

There is however, a subtlety that must be taken care of. A reader may obtain a value ùë£ with sequence number ùë† , and later read a value ùë£ + 2 with sequence number ùë† ‚Ä≤ &gt; ùë† + 1. This leaks to the reader that some writeMax operations occur in between its read operations, and in particular, that a writeMax ( ùë£ + 1 ) occurred, without ever effectively reading ùë£ + 1.

To deal with this problem, we append a random nonce ùëÅ to the argument of a writeMax operation, where ùëÅ is a random number. The pair ( ùë§, ùëÅ ) is used as the value written ùë£ was used in Alg. 1. The pairs ( ùë§, ùëÅ ) are ordered lexicographically, that is, first by their value ùë§ and then by their nonce ùëÅ . Thus, the reader cannot guess intermediate values. The code for read and audit is slightly adjusted in Alg. 2 versus Alg. 1, to ignore the random nonce ùëÅ from the pairs when values are returned.

In the algorithm, a (non-auditable) max-register ùëÄ is shared among the writers. A writeMax( ùë§ ) by ùëù starts by writing the pair ùë£ = ( ùë§, ùëÅ ) of the value ùë§ and the nonce ùëÅ to ùëÄ , before entering a repeat loop. Each iteration is an attempt to store in ùëÖ the current value ùëöùë£ùëéùëô of ùëÄ , and the loop terminates as soon as ùëÖ holds a value equal to or larger than ùëöùë£ùëéùëô . Like in Alg. 1, ùëÖ holds a triplet ( ùë†, ùë£ùëéùëô, ùëèùëñùë°ùë† ) where ùë† is ùë£ùëéùëô 's sequence number, ùë£ùëéùëô is the current value, and ùëèùëñùë°ùë† is the encrypted set of readers of ùë£ùëéùëô . Before attempting to change ùëÖ ùë£ùëéùëô , and the set of readers, once deciphered, are stored in the registers ùëâ ùë† [ ] and ùêµ ùë† [ ] , from which they can be retrieved with audit.

In each iteration of the repeat loop, the access pattern of write in Alg. 1 to the shared register SN and ùëÖ is preserved. After obtaining a new sequence number ùë† + 1, where ùë† is the current value of ùëÜùëÅ (line 24 for the first iteration, line 30 otherwise), a triple ( ùëôùë†ùëõ, ùëôùë£ùëéùëô, ùëèùëñùë°ùë† ) is read from ùëÖ . If ùëôùë£ùëéùëô ‚â• ùë£ , the loop breaks as a value that is equal to or larger than ùë£ has already been written. As in Alg. 1, before returning we make sure that the sequence number in ùëÜùëÅ is at least as large as ùëôùë†ùëõ , the sequence number in ùëÖ .

## 5 AUDITABLE SNAPSHOT OBJECTS AND VERSIONED TYPES

We show how an auditable max register (Section 4) can be used to make other object types auditable.

## 5.1 Making Snapshots Auditable

We start by showing how to implement an auditable ùëõ -component snapshot object, relying on an auditable max register. Each component has a state, initially ‚ä• , and a different designated writer process. A view is an ùëõ -component array, each cell holding a value written by a process in its component. A atomic object [1] provides two operations: update( ùë£ ) that changes the process's component to ùë£ , and scan that returns a view. It is required that in any sequential execution, in the view returned by a scan, each component contains the value of the latest update to this component (or ‚ä• if there is no previous update). As for the auditable register, an audit operation returns a set of pairs ( ùëó, ùë£ùëñùëíùë§ ) . In a sequential execution, there is such a pair if and only if the operation is preceded by a scan by process ùëù ùëó that returns ùë£ùëñùëíùë§ . Here, we want that audits report exactly those scans that have made enough progress to infer the current ùë£ùëñùëíùë§ of the object.

Denysuk and Woeffel [11] show that a strongly-linearizable max register can be used to transform a linearizable snapshot into its strongly linearizable counterpart. As we explain next, with the same technique, non-auditable snapshot objects can be made auditable. Algorithm 3 adds an audit operation to their algorithm. Their implementation is lock-free, as they rely on a lock-free implementation of a max register. Algorithm 3 is wait-free since we use the wait-free max-register implementation of Section 4.

Let ùëÜ be a linearizable, but non-auditable snapshot object. The algorithm works as follows: each new state (that is, whenever one component is updated) is associated with a unique and increasing version number . The version number is obtained by storing a sequence number ùë†ùëõ ùëñ in each component ùëñ of ùëÜ , in addition to its current value. Sequence number ùë†ùëõ ùëñ is incremented each time the ùëñ th component is updated (line 2). Summing the sequence numbers of the components yields a unique and increasing version number ( ùë£ùëõ ) for the current view.

The pairs ( ùë£ùëõ, ùë£ùëñùëíùë§ ) , where ùë£ùëõ is a version number and ùë£ùëñùëíùë§ a state of the auditable snapshot, are written to an auditable max register ùëÄ . The pairs are ordered according to the version number, which is a total order since version numbers are unique. Therefore, the latest state can be retrieved by reading ùëÄ , and the set of past scan operations can be obtained by auditing ùëÄ (line 10). The current view of the auditable snapshot is stored in ùëÜ .

In an update( ùë£ ), process ùëù ùëñ starts by updating the ùëñ th component of ùëÜ with ùë£ and incrementing the sequence number field ùë†ùëõ ùëñ . It then scans ùëÜ , thus obtaining a new view of ùëÜ that includes its update. The view ùë£ùëñùëíùë§ of the implemented auditable snapshot is obtained by removing the sequence number in each component (line 4). The version number ùë£ùëõ associated with this view is the sum of the sequence numbers. It then writes ( ùë£ùëõ, ùë£ùëñùëíùë§ ) to the max-register ùëÄ (line 5). A scan operation reads a pair ( ùë£ùëõ, ùë£ùëñùëíùë§ ) from ùëÄ and returns the corresponding ùë£ùëñùëíùë§ (line 7). Since ùëÄ is auditable, the views returned by the processes that have previously performed a scan can thus be inferred by auditing ùëÄ (line 10).

The audit and scan operations interact with the implementation by applying a single operation (audit and read, respectively) to the auditable max register ùëÄ . The algorithm therefore lifts the properties of the implementation of ùëÄ to the auditable snapshot object. In particular, when the implementation presented in Section 4 is used, effective scan operations are auditable, scan operations are uncompromised by other scanners, and update operations are uncompromised by scanners.

## 5.2 Proof of Correctness

Let ùõº be a finite execution of Algorithm 3. To simplify the proof, we assume the inputs of update by the same process are unique.

| Algorithm 3 ùëõ -component auditable snapshot objects. 1:   | Algorithm 3 ùëõ -component auditable snapshot objects. 1:                                                                                                                                                                                                        | ‚ä≤ code for writer ùëù , ùëñ 1 , . . . , ùëõ   |
|-----------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------|
|                                                           | shared registers M : auditable max register, initially ( 0 , [‚ä• , . . . , ‚ä•]) S : (non-auditable) snapshot object, initially [( 0 , ‚ä•) , . . . , ( 0 , ‚ä•)] local variable: writer ùëù ùëñ , 1 ‚â§ ùëñ ‚â§ ùëõ ùë†ùëõ ùëñ local sequence number, initially 0 function update( ùë£ ) | ùëñ ‚àà { }                                 |
| 2:                                                        | ùë†ùëõ ùëñ ‚Üê ùë†ùëõ ùëñ + 1; ùëÜ. update ùëñ (( ùë†ùëõ ùëñ , ùë£ ))                                                                                                                                                                                                                    |                                         |
| 3:                                                        | ùë†ùë£ùëñùëíùë§ ‚Üê ùëÜ. scan () ; ùë£ùëõ ‚Üê Àù 1 ‚â§ ùëó ‚â§ ùëõ ùë†ùë£ùëñùëíùë§ [ ùëó ] .ùë†ùëõ ùë£ùëñùëíùë§ ‚Üê the ùëõ -component array of the values in ùë†ùë£ùëñùëíùë§                                                                                                                                                     |                                         |
| 5:                                                        | ùëÄ. writeMax (( ùë£ùëõ, ùë£ùëñùëíùë§ )) ; return                                                                                                                                                                                                                            |                                         |
| 6:                                                        | function scan( )                                                                                                                                                                                                                                               |                                         |
| 7:                                                        | ( _ , ùë£ùëñùëíùë§ ) ‚Üê ùëÄ. read () ; return ùë£ùëñùëíùë§                                                                                                                                                                                                                        |                                         |
| 8:                                                        | function audit( )                                                                                                                                                                                                                                              |                                         |
| 9:                                                        | MA ‚Üê ùëÄ. audit () ;                                                                                                                                                                                                                                             |                                         |
| 10:                                                       | return {( ùëó, ùë£ùëñùëíùë§ ) : ‚àÉ an element ( ùëó, (‚àó , ùë£ùëñùëíùë§ )) ‚àà MA                                                                                                                                                                                                      |                                         |

Weassumethat the implementation of ùëÄ is wait-free and linearizable. In addition, it guarantees effective linearizability and that read operations are uncompromised by other readers. We also assume that the implementation of ùëÜ is linearizable and wait-free (e.g.,[1]). Inspection of the code shows that update, scan and audit operations are wait-free.

Since

ùëÜ

and

ùëÄ

are linearizable and linearizability is composable,

ùõº

can be seen as a sequence of steps applied to

ùëÜ

or

ùëÄ

.

In particular, we associate with each high-level operation linearization

ùëúùëù

a step

ùúé ùëúùëù

(

)

applied by

ùëúùëù

either to

ùëÜ

or to

ùëÄ

.

The

ùêø ùõº

(

)

of

ùõº

is the sequence formed by ordering the operations according to the order their associated step occurs in

ùõº

.

For a scan and an audit operation ùëúùëù , ùúé ùëúùëù ( ) is, respectively, the read and the audit steps applied to ùëÄ . If ùëúùëù is an update with input ùë• by process ùëù ùëñ , then let ùë£ùëõ ùë• be the sum of the sequence numbers ùë†ùëõ in each component of ùëÜ after update ( ùë• ) has been applied to ùëÜ by ùëù ùëñ . ùúé ùëúùëù ( ) is the first write to ùëÄ of a pair ( ùë£ùëõ, ùë£ùëñùëíùë§ ) with ùë£ùëõ ‚â• ùë£ùëõ ùë• and ùë£ùëñùëíùë§ [ ùëñ ] = ùë• . If there is no such write , ùëúùëù is discarded.

We first show that the linearization ùêø ùõº ( ) respects the real-time order between operations.

Lemma 9. If an operation ùëúùëù completes before an operation ùëúùëù ‚Ä≤ is invoked in ùõº , then ùëúùëù precedes ùëúùëù ‚Ä≤ in ùêø ùõº ( ) .

Proof. We show that that the linearization point of any operation ùëúùëù is inside its execution interval; the claim is trivial for scan or audit operations.

Suppose that ùëúùëù is an update by a process ùëù ùëñ with input ùë• . The sum of the sequence numbers in the components of ùëÜ increases each time an update is applied to it. Hence, any pair ( ùë£ùëõ, ùë£ùëñùëíùë§ ) written to ùëÄ before ùëù ùëñ has updated its component of ùëÜ to ùë• is such that ùë£ùëõ &lt; ùë£ùëõ ùë• . Therefore ùúé ùëúùëù ( ) , if it exists, is after ùëúùëù starts. If ùëúùëù terminates, then it scans ùëÜ after updating the ùëñ th component of ùëÜ to ùë• . The ùë£ùëñùëíùë§ it obtains and its associated version number satisfy ùë£ùëñùëíùë§ [ ùëñ ] = ùë• and ùë£ùëõ ‚â• ùë£ùëõ ùë• . This pair is written to ùëÄ . If ùúé ùëúùëù ( ) is not this step, then ùúé ùëúùëù ( ) occurs before ùëúùëù terminates. If ùëúùëù does not terminate and ùúé ùëúùëù ( ) does exist, it occurs after ùëúùëù starts and thus within ùëúùëù 's execution interval. ‚ñ°

Lemma 10. Each component ùëñ of the view returned by a scan is the input of the last update by ùëù ùëñ linearized before the scan in ùêø ùõº ( ) .

Proof. Consider a scan operation ùë†ùëúùëù that returns ùë£ùëñùëíùë§ , with ùë£ùëñùëíùë§ [ ùëñ ] = ùë• . This view is read from the max register ùëÄ and has version number ùë£ùëõ . Let ùëúùëù be the last update by ùëù ùëñ linearized before ùë†ùëúùëù in ùêø ùõº ( ) , let ùë¶ be its input and ùë£ùëõ ùë¶ the version number (that is the sum of the sequence number stored in each component) of ùëÜ immediately after ùëÜ. update ( ùë¶ ) is applied by ùëù ùëñ .

We denote by ùúé ùë¢ this low level update . Since the version number increases with each update , every pair ( ùë£ùëõ , ùë£ùëñùëíùë§ ‚Ä≤ ‚Ä≤ ) written into ùëÄ before ùúé ùë¢ is such that ùë£ùëõ ‚Ä≤ &lt; ùë£ùëõ ùë¶ . Also, every pair ( ùë£ùëõ , ùë£ùëñùëíùë§ ‚Ä≤ ‚Ä≤ ) written to ùëÄ after ùúé ùë¢ and before ùë†ùëúùëù is linearized satisfies ùë£ùëõ ‚Ä≤ ‚â• ùë£ùëõ ùë¶ = ‚áí ùë£ùëñùëíùë§ ‚Ä≤ [ ùëñ ] = ùë¶ . Indeed, if ùë£ùëõ ‚Ä≤ ‚â• ùë£ùëõ ùë¶ , ùë£ùëñùëíùë§ ‚Ä≤ is obtained by a scan of ùëÜ applied after the ùëñ -th component is set to ùë¶ . Hence, ùë£ùëñùëíùë§ ‚Ä≤ [ ùëñ ] = ùë¶ because we assume that ùëúùëù is the last update by ùëù ùëñ linearized before ùë†ùëúùëù in ùêø ùõº ( ) .

Finally, step ùúé ùëúùëù ( ) is a write of pair ( ùë£ùëõ , ùë£ùëñùëíùë§ ‚Ä≤ ‚Ä≤ ) to ùëÄ with ùë£ùëõ ‚Ä≤ ‚â• ùë£ùëõ ùë¶ and ùë£ùëñùëíùë§ ‚Ä≤ [ ùëñ ] = ùë¶ ùúé ùëúùëù . ( ) occurs after ùúé ùë¢ and before the max register ùëÄ is read by ùë†ùëúùëù . It thus follows that the pair ( ùë£ùëõ, ùë£ùëñùëíùë§ ) read from ùëÄ in ùë†ùëúùëù satisfies ùë£ùëõ ‚â• ùë£ùëõ ùë¶ and has been written after ùúé ùë¶ . Hence, ùë£ùëñùëíùë§ [ ùëñ ] = ùë¶ = ùë• . We conclude that each component ùëñ of the view returned by a scan is the input of the last update by ùëù ùëñ linearized before the scan in ùêø ùõº ( ) . ‚ñ°

Lemma11. An audit reports ( ùëó, ùë£ùëñùëíùë§ ) if and only if ùëù ùëó has a ùë£ùëñùëíùë§ -effective 2 scan in ùõº . Each update ( ùë£ ) is uncompromised by a scanner ùëù ùëó unless it has a ùë£ùëñùëíùë§ -effective scan with one component of ùë£ùëñùëíùë§ equal to ùë£ . Each scan by ùëù ùëò is uncompromised by a scanner ùëù ùëó ‚â† ùëù ùëò .

Proof. A scan applies a single operation on shared objects, namely a read on ùëÄ . It is linearized with this step, which determines the view it returns. Therefore, a scan is linearized if and only if it is effective. Hence ( ùëó, ùë£ùëñùëíùë§ ) is reported by an audit if and only if ùëù ùëó has a ùë£ùëñùëíùë§ -effective scan.

Let ùë£ be the input of an update operation by some process ùëù ùëñ . If there is no ùë£ùëñùëíùë§ with ùë£ùëñùëíùë§ [ ùëñ ] = ùë£ written to ùëÄ (line 5), update( ùë£ ) can be replaced by update( ùë£ ‚Ä≤ ), ùë£ ‚Ä≤ ‚â† ùë£ in an execution ùõº ‚Ä≤ , ùõº ùëù ùëó ‚àº ùõº ‚Ä≤ . Otherwise, note that each ùë†ùë£ùëñùëíùë§ for which ùëù ùëó has a ùë†ùë£ùëñùëíùë§ -effective scan, we have ùë†ùë£ùëñùëíùë§ [ ùëñ ] ‚â† ùë£ . Suppose that ùë£ùëñùëíùë§ , with ùë£ùëñùëíùë§ [ ùëñ ] = ùë£ is written to ùëÄ in ùõº . Then we can replace ùë£ùëñùëíùë§ with an array ùë£ùëñùëíùë§ ‚Ä≤ , identical to ùë£ùëñùëíùë§ except that ùë£ùëñùëíùë§ ‚Ä≤ [ ùëñ ] = ùë£ ‚Ä≤ ‚â† ùë£ an execution ùõº ‚Ä≤ ùëù ùëó ‚àº ùõº . This is because the write of ùë£ùëñùëíùë§ is not compromised by ùëù ùëó in ùëÄ . By repeating this procedure until all writes to ùëÄ of ùë£ùëñùëíùë§ s with ùë£ùëñùëíùë§ [ ùëñ ] = ùë£ have been eliminated leads to an execution ùõΩ, ùõΩ ùëù ùëó ‚àº ùõº in which there is no update( ùë£ ). ‚ñ°

Theorem 12. Alg. 3 is a wait-free linearizable implementation of an auditable snapshot object which audits effective scan operations, in which scan and update are uncompromised by scanners.

## 5.3 Versioned Objects

Snapshot objects are an example of a versioned type [11], whose successive states are associated with unique and increasing version numbers. Furthermore, the version number can be obtained from the object itself, without resorting to external synchronization primitives. Essentially the same construction can be applied to any versioned object.

An object ùë° ‚àà T is specified by a tuple ( ùëÑ,ùëû , ùêº, ùëÇ, ùëì , ùëî 0 ) , where ùëÑ is the state space, ùêº and ùëÇ are respectively the input and output sets of update and read operations. ùëû 0 is the initial state and functions ùëì : ùëÑ ‚Üí ùëÇ and ùëî : ùêº √ó ùëÑ ‚Üí ùëÑ describes the sequential behavior of read and update . A read () operation leaves the current state ùëû unmodified and returns ùëì ( ùëû ) . An update ( ùë£ ) , where ùë£ ‚àà ùêº changes the state ùëû to ùëî ùë£, ùëû ( ) and does not return anything.

A linearizable versioned implementation of a type ùë° ‚àà T can be transformed into a strongly-linearizable one [11], as follows. Let ùë° = ( ùëÑ,ùëû , ùêº, ùëÇ, ùëì , ùëî 0 ) be some type in T . Its versioned variant ùë° ‚Ä≤ = ( ùëÑ ,ùëû , ùêº ‚Ä≤ ‚Ä≤ 0 ‚Ä≤ , ùëÇ ‚Ä≤ , ùëì ‚Ä≤ , ùëî ‚Ä≤ ) has ùëÑ ‚Ä≤ = ùëÑ √ó N ,

2 Namely, ùëù ùëñ has a scan operation that returns ùë£ùëñùëíùë§ in all indistinguishable executions.

ùëû ‚Ä≤ 0 = ( ùëû , 0 0 , ) ùêº ‚Ä≤ = ùêº , ùëÇ ‚Ä≤ = ùëÇ √ó N , ùëì ‚Ä≤ : ùëÑ ‚Ä≤ ‚Üí ùëÇ √ó N and ùëî ‚Ä≤ : ùêº √ó ùëÑ ‚Ä≤ ‚Üí ùëÑ ‚Ä≤ . That is, the state of ùë° ‚Ä≤ is augmented with a version number, which increases with each update and is returned by each read : ùëì ‚Ä≤ (( ùëû, ùë£ùëõ )) = ( ùëì ( ùëû , ùë£ùëõ ) ) and ùëî ‚Ä≤ (( ùëû, ùë£ùëõ )) = ( ùëî ùëû , ùë£ùëõ ( ) ‚Ä≤ ) with ùë£ùëõ &lt; ùë£ùëõ ‚Ä≤ .

A versioned implementation of a type ùë° ‚àà T can be transformed into an auditable implementation of the same type using an auditable register. The construction is essentially the same as presented in Algorithm 3. In the auditable variant ùëá ùëé of ùëá , to perform an update( ùë£ ), a process ùëù first update the versioned implementation ùëá before reading it. ùëù hence obtains a pair ( ùëú, ùë£ùëõ ) that it writes to the auditable max register ùëÄ . For a read, a process returns what it reads from ùëÄ . As read amounts to read ùëÄ , to perform an audit a process simply audit the max-register ùëÄ . As we have seen for snapshots, ùëá ùëé is linearizable and wait-free. Moreover, ùëá ùëé inherits the advanced properties of the underlying max-register: If ùëÄ is implemented with Algorithm 2, then it correctly audits effective read, and read and update are uncompromised.

Theorem 13 (versioned types are auditable). Let ùë° ‚àà T , and let ùëá be a versioned implementation of ùë° that is linearizable and wait-free. There exists a wait-free, linearizable and auditable implementation of ùë° from ùëá and auditable max-registers in which read and update are uncompromised by readers and audit reports only effective read operations.

## 6 DISCUSSION

This paper introduces novel notions of auditability that deal with curious readers. We implement a wait-free linearizable auditable register that tracks effective reads while preventing unauthorized audits by readers. This implementation is extended into an auditable max register, which is then used to implement auditable atomic snapshots and versioned types.

Many open questions remain for future research. An immediate question is how to implement an auditable register in which only auditors can audit , i.e., reads are uncompromised by writers. A second open question is how to extend auditing to additional objects. These can include, for example, partial snapshots [4] in which a reader can obtain an 'instantaneous' view of a subset of the components. Another interesting object is a clickable atomic snapshot [16], in particular, variants that allow arbitrary operations on the components and not just simple updates (writes).

The property of uncompromising other accesses can be seen as an internal analog of history independence , recently investigated for concurrent objects [3]. A history-independent object does not allow an external observer, having access to the complete system state , to learn anything about operations applied to the object, but only its current state. Our definition, on the other hand, does not allow an internal observer, e.g., a reader that only reads shared base objects, to learn about other read and write operations applied in the past. An interesting intermediate concept would allow several readers collude and to combine the information they obtain in order to learn more than what they are allowed to.

## ACKNOWLEDGMENTS

H. Attiya is supported by the Israel Science Foundation (grant number 22/1425). A. Fern√°ndez Anta has been funded by project PID2022-140560OB-I00 (DRONAC) funded by MICIU / AEI / 10.13039 / 501100011033 and ERDF, EU. A. Milani is supported by the France 2030 ANR project ANR-23-PECL-0009 TRUSTINCloudS. C. Travers is supported in part by ANR projects DUCAT (ANR-20-CE48-0006).
<|endofpaper|>